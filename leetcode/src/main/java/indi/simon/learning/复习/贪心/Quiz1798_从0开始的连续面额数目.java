package indi.simon.learning.复习.贪心;

import java.util.Arrays;

/**
 * @author chenzhuo(zhiyue)
 *
 * 给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。
 *
 * 请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。
 *
 * 你可能有多个相同值的硬币。
 *
 * 示例 1：
 *
 * 输入：coins = [1,3]
 * 输出：2
 * 解释：你可以得到以下这些值：
 * - 0：什么都不取 []
 * - 1：取 [1]
 * 从 0 开始，你可以构造出 2 个连续整数。
 * 示例 2：
 *
 * 输入：coins = [1,1,1,4]
 * 输出：8
 * 解释：你可以得到以下这些值：
 * - 0：什么都不取 []
 * - 1：取 [1]
 * - 2：取 [1,1]
 * - 3：取 [1,1,1]
 * - 4：取 [4]
 * - 5：取 [4,1]
 * - 6：取 [4,1,1]
 * - 7：取 [4,1,1,1]
 * 从 0 开始，你可以构造出 8 个连续整数。
 * 示例 3：
 *
 * 输入：nums = [1,4,10,3,1]
 * 输出：20
 * 提示：
 *
 * coins.length == n
 * 1 <= n <= 4 * 104
 * 1 <= coins[i] <= 4 * 104
 */
public class Quiz1798_从0开始的连续面额数目 {

    public static void main(String[] args) {
        Quiz1798_从0开始的连续面额数目 quiz1798NeedReview = new Quiz1798_从0开始的连续面额数目();
        int res = quiz1798NeedReview.getMaximumConsecutive(new int[]{1, 1, 1, 596, 266, 210, 766, 579, 1, 195, 1, 1, 230, 1, 465, 1, 1, 1, 538, 1, 1, 125, 624, 62, 239, 1, 1, 1, 1, 874, 1, 307, 186, 1, 1, 879, 1, 933, 681, 680, 1, 1, 1, 757, 1, 903, 975, 104, 1, 742, 516, 1, 541, 1, 1, 1, 661, 529, 628, 721, 1, 1, 38, 493, 434, 813, 270, 380, 1, 1, 1, 448, 226, 1, 1, 1, 1, 1, 360, 1, 411, 699, 717, 1, 1, 483, 1, 1, 1, 1, 1, 1, 427, 1, 931, 857, 871, 1, 96, 1, 1, 556, 898, 1, 1, 1, 1, 873, 1, 608, 1, 515, 134, 1, 1, 606, 780, 863, 1, 1, 1, 774, 87, 639, 1, 1, 209, 1, 394, 1, 1, 864, 1, 395, 737, 523, 1, 348, 1, 328, 1, 16, 1, 1, 1, 1, 1, 210, 789, 729, 1, 713, 1, 614, 64, 429, 1, 1, 241, 866, 541, 324});
        System.out.println(res);
    }

    //todo: 官方贪心，这里使用贪心的方法是，找到一个我们能凑出的硬币面额区间[0,x]，然后我们再coins里面从小到大扫过去，来扩充这个区间，
    // 扩充的方法是，如果剩余硬币中最小面额是y，那么将该面额的硬币使用进来之后，我们可以凑出的面额区间肯定能覆盖[y,x+y]，结合之前我们已经能凑出的[0,x]，
    // 只要[0,x]和[y,x+y]能接上，也就是y<=x+1的话，那么我们就能将能凑出的面额区间扩充到[0,x+y]，否则两个区间接不上，到此就结束了，能凑出的最大数也就是x。
    // 如果能接上，此时区间新的上限就是x+y，再重复以上步骤继续遍历coins即可
    public int getMaximumConsecutive(int[] coins) {
        //x代表目前为止我们所能凑出的从0开始连续面额的上限，
        // 初始值代表我们任何硬币都不选，就能凑出[0,0]这个面额区间，其上限是0
        int x = 0;
        //一定要排序，因为需要从小找到大，
        Arrays.sort(coins);
        for (int y : coins) {
            //因为是排序好的，所以如果硬币面额比当前x+1还大了，说明[0,x]与[y,x+y]无论如何也接不上了，到x就完事儿了，退出
            if (y > x + 1) {
                break;
            }
            x += y;
        }
        //todo: 要记住返回x+1，因为一个都不选得到0也算
        return x + 1;
    }

}
